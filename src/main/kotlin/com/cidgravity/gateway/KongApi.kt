package com.cidgravity.gateway

import com.cidgravity.kong.generated.FRoute
import com.cidgravity.kong.generated.FService
import com.cidgravity.kong.generated.Kong_json_schema
import com.cidgravity.openapi.shared.addPath
import com.cidgravity.service.ALL_SERVICES
import com.cidgravity.service.IService
import com.cidgravity.shared.Util
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.fasterxml.jackson.dataformat.yaml.YAMLGenerator
import io.swagger.v3.oas.models.PathItem.HttpMethod
import io.swagger.v3.oas.models.security.SecurityScheme
import java.io.File
import java.nio.file.Paths
import kotlin.io.path.absolutePathString

// basename == filename slug without extension
internal fun Kong_json_schema.writeToYamlFile(
    basename: String,
    directory: String = Paths.get("").absolutePathString()
) {
    val filename = "${directory}/${basename}.yaml"
    try {
        val objectMapper = ObjectMapper(YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER))
        objectMapper
            .writerWithDefaultPrettyPrinter()
            .writeValue(File(filename), this)
        println("Successfully generated '${filename}'")
    } catch (e: Exception) {
        println("Error while attempting to generate '${filename}'")
        e.printStackTrace()
    }
}

object KongApi {

    val associatedServices = ALL_SERVICES
    val projectTag = "api"

    val pathParamPattern = """\{([^/]+)\}""".toRegex()

    private fun getTags(service: IService, securityType: SecurityScheme.Type? = null): List<String> {
        return if (securityType != null) {
            listOf(
                projectTag,
                service.id,
                securityType.toString()
            )
        } else {
            listOf(
                projectTag,
                service.id,
            )
        }
    }

    // upstreams will be filled by the infrastructure team before the kong.yaml generated by this api
//    private fun getUpstreams(): List<FUpstream> {
//        val upstreams: MutableList<FUpstream> = mutableListOf()
//        for (service in associatedServices) {
//                upstreams.add(
//                    FUpstream()
//                        .withTags(
//                            getTags(service)
//                        )
//                        .withName("${projectTag}_${service.id}_upstream")
//                        .withTargets(
//                            service.servers.map { server ->
//                                FTarget()
//                                    .withTags(
//                                        getTags(service)
//                                    )
//                                    // target content will be manually changed by the infra team later
//                                    .withTarget( if (server.port < 0) server.host else "${server.host}:${server.port}")
//                            }
//                        )
//                )
//        }
//        return upstreams
//    }

    private fun getRoute(service: IService, endpoint: Util.StandardEndpoint, standardSecurity: Util.StandardSecurity): FRoute {
        // replace path param like {timeRange} to kong path param style (?<timeRange>[^/\]+)$
        var path = Util.getPrefixedPath(endpoint.path, standardSecurity.type)
        val results = pathParamPattern.findAll(endpoint.path)
        for (result in results) {
            val groups = result.groupValues
            path = path.replace(groups[0], "(?<${groups[1]}>[^\\/]+)$")
        }
        // in version 3.0 every route that use regex must start with '~'
        // see https://docs.konghq.com/deck/latest/3.0-upgrade/
        if (!results.none()) {
            path = "~$path"
        }
        // OPTIONS is necessary for CORS to function correctly
        // (browsers automatically send an OPTIONS before every request)
        val allMethodsWithOption = setOf(HttpMethod.OPTIONS) union endpoint.methods
        return FRoute()
            .withTags(
                getTags(service, standardSecurity.type)
            )
            // we need to replace '/' in path with '-' because otherwise kong throws:
            // the only accepted ascii characters are alphanumerics or ., -, _, and ~)
            .withName("${projectTag}_${service.id}_${standardSecurity.type}_${endpoint.path.replace("/", "-")}")
            .withMethods(
                allMethodsWithOption.map { method -> method.name }
            )
            .withPaths(
                listOf(path)
            )
            .withStrip_path(false)
            .withPlugins(
                standardSecurity.kongSecurities.toList()
            )

    }

    private fun getServices(): List<FService> {
        val services: MutableList<FService> = mutableListOf()
        for (service in associatedServices) {
            val routes = mutableListOf<FRoute>()
            for ((standardSecurity, endpoints) in service.getEndpointsBySecurities()) {
                for (endpoint in endpoints) {
                    val route = getRoute(service, endpoint, standardSecurity)
                    routes.add(route)
                }
            }
            services.add(
                    FService()
                        .withTags(
                            getTags(service)
                        )
                        .withName("${projectTag}_${service.id}_service")
                        .withProtocol("http")
                        .withHost("${service.id}_upstream") // a service for each auth method, but one unique underlying service behind
                        .withPath("/")
                        .withRoutes(routes)
                )
        }
        return services.toList()
    }

    fun get(): Kong_json_schema {
        return Kong_json_schema()
            .with_format_version("3.0")
            //        .withUpstreams(   // upstreams will be filled by the infrastructure team before the kong.yaml generated by this api
            //            getUpstreams()
            //        )
            .withServices(
                getServices()
            )
    }
}